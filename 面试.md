# 那些操作会造成内存泄露
- 闭包
- 意外的全部变量，比如没有声明的变量(没有var的变量)
- 定时器，没被清理
- 脱离dom的引用

# es6的新特性
块级作用域
类
箭头函数
模版字符串
对象数组的方法扩展 ：解构，异步的generate 。。。
symbol set map 
展开运算符

# 高阶函数
将函数作为参数、返回值的函数

# 执行上下文
当js执行时，会产生三种执行上下文
· 全局执行上下文
· 函数执行上下文
· eval执行上下文
每个上下文都有三个重要是属性：变量对象，作用域链，this
### 函数执行上下文有两个阶段：
1、创建阶段：js解释器会找出需要提升的变量和函数，函数的话会将整个函数存入内存中，然后变量的话只声明然后赋值undefined
2、执行阶段：就可以提前使用这些变量和函数
且函数优先与变量，相同名字的函数会覆盖上一个同名函数

# 作用域和作用域链
作用域：表示定义变量的区域
作用域链：表示一条访问链，访问那些在执行环境内所能访问到的变量和函数，并且是有序访问。
        作用域链始终从当前执行环境的变量对象开始到全局执行环境的变量对象为止
        **作用域链是在定义时就被确定下来的，和剪头函数中的this一样，一旦确定就不会改变了**
        **而普通函数的this是在调用时才能确定下来的**
作用域分为三种：
· 全局作用域：挂在window对象的变量，任何位置都能访问到
· 函数作用域：只有函数内部才能访问到，（除非闭包）
· 块级作用域：es6新增，let和const声明，在if和for语句后面的{...}里面就是块级作用域，
           并且声明的变量在定于之前是不能被访问的, 所以let声明的变量在声明前不能使用

# 闭包
闭包其实就是一个可以**从外部访问其他函数内部变量的函数**。并且让这些变量始终保存在内存中。
闭包产生的原因：作用域链在变量定义的时候就产生的，代码解释器会首先在当前作用域开始查找，如果找不到，会去到父级作用域找，依此类推。。。
### 闭包的表现形式：
1、return一个函数
2、回调函数：比如定时器，回调函数，事件监听都是使用闭包，
3、立即执行函数

### 闭包的用途
1、可以在外部访问函数内部的属性
2、可以将已经运行结束的函数上下文中的变量保存下来

# new 的原理
### new 做了哪些事？
- 创建一个新对象
- 将新对象连接到构造函数原型上，并且绑定this指向新对象
- 执行构造函数，为新对象添加属性
- 返回这个新对象
new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是return一个和this无关普通对象(不会走步骤生成this对象)，如果返回一个基本类型数据，则仍然会返回一个实例对象

#  原型/原型链
## __proto__和prototype的关系？
总结一句话：__proto__和construct是对象上所有，prototype是构造函数所有
prototype对象包含了构造函数的所有
__proto__指向创建对象的构造函数原型
__proto__相当于一个指针指向构造函数的原型prototype，一般用Object.getPrototype(p)、p.construct.prototype获取，Object.setPrototype()设置
## 原型链
查找一个对象的某个属性或者方法， 会现在对象本身查找，如果查找不到会往对象的原型上找，对象的原型上查不到，就往对象原型的原型上找（最终会查到Object.prototype上），依此类推，这样就形成一条链式结构，称为原型链

## const定义变量问题
const是用来定义常量的，一旦定义后不可以修改，对于基本类型来说，一旦修改了就会直接报错。
对于引用类型来说，用const定义变量赋值以一个引用类型，其实赋值给这个变量一个引用地址，然后修改引用类型只是修改它的属性值，但对于赋值的引用地址，其实不是不会修改到的，所以用const定义一个变量，其属性值时可以被修改的。

