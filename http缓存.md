## HTTP缓存
需要加载的资源有html、css、js、img...

进入网站 加载出页面的过程： cpu计算、页面渲染、网络请求
其中网络请求的耗时最长， 而且没必要每次打开页面都要重新加载相同的资源
通过HTTP缓存可以减少网络请求的体积和数量，提高加载速度


## 什么强缓存？
expires: http1.0规范，值为一个绝对时间的GMT格式的时间字符串，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。
这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，就是因为本地时间可以随便更改，导致缓存混乱。
Cache-Control（优先级比expires高）: http1.1规范，值为一个包含多个缓存控制指令的列表，比如 Cache-Control:max-age=31536000，
no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
no-store：禁止使用缓存，每一次都要重新请求数据。
public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。

服务器根据判断请求文件需要被缓存，在返回响应体时会设置expire和Cache-Control：max-age，告知浏览器在本地缓存对应的资源和响应体。
等下次请求同一份资源时浏览器会检查本地缓存资源的header信息比如cache-control是否过期，如果max-age没有过期时就可以走本地缓存而不用重新请求了，如果过期了会走协商缓存阶段。

命中强缓存不会发出请求到服务器

## 什么是协商缓存？
（！！！浏览器向服务端发送请求，服务器会返回资源和响应头，浏览器会将响应头存储在本地缓存中。）
资源标识：last-modify/if-modified-since 和 eTag/if-none-match
然后下次浏览器再次请求资源时，会一同带上资源标识，服务器会根据资源标识判断是否为最新资源，
如果不是最新资源，重新发起http请求，服务器返回的状态码200，和最新的资源和最新的资源标识
如果还是最新的资源，服务器会返回304状态码，告知浏览器直接去本地缓存中拿资源


## 什么是资源标识？
每次服务器返回给浏览器都会返回一个Last-Modified字段(资源上次修改的时间)或者ETag(资源对应的唯一字符串)。优先使用ETag，因为Last-Modified只精确到秒
然后浏览器下次请求的时候会在请求头内带上If-Modified-Since（Last-Modified）和If-None-Match（ETag），然后走协商缓存


## http请求缓存的流程：
0、如果是第一次请求，。。。。
1、先判断是否有本地缓存，
   如果没有，直接发出http请求，
   如果有缓存，就浏览器根据响应体内Cache-Control：max-age，来判断缓存是否过期
2、如果缓存没有过期，则直接走强制缓存，取本地缓存资源
   如果缓存过期了或者Cache-Control 的属性设置为 no-cache，再或者根本没有Cache-Control，则服务器会根据缓存起来的响应体内的Last—Modified、ETag，判断是否为最新资源
3、如果是最新的，服务器不会返回资源，会告诉浏览器继续使用本地缓存，状态码是304
   如果不是最新资源，就返回最新的资源和响应体信息，状态码是200


当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
当 f5刷新网页时，跳过强缓存，但是会检查协商缓存；