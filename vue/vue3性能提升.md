## Vue3.0性能提升主要是体现在哪些方面
### 1. 响应式系统升级
- Vue2的核心是Object.defineProperty, 劫持整改对象，然后递归深度遍历所有属性，为每个属性添加getter和setter。
- Vue3的核心是Proxy，直接劫持整个对象，并通过Reflect操作对象内部属性，不再需要遍历递归。
  - 可以监听动态新增、删除的属性
  - 可以监听数组的索引和length属性
  - 实现原理
    1. 利用Proxy, 包装整个对象，拦截对象中任意属性的变化，包括属性值的读写、属性的添加和删除等
    2. 利用Reflect, 保证Proxy的所有操作都对应有Reflect方法，且Reflect方法的返回值就是Proxy方法返回值
    3. 利用ES6的Proxy和Reflect, 实现一个数据监听和响应式原理
#### 为什么Proxy一定要配合Reflect使用？
- Proxy 代理，它内置了一系列“劫持方法”用于创建一个对象的代理，从而实现基本操作的拦截和自定义行为（如属性查找、赋值、枚举、函数调用等）。
- Reflect 反射，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。
- 简单来说，我们可以通过 Proxy 创建对于原始对象的代理对象，从而在代理对象中使用 Reflect 达到对于 JavaScript 原始操作的拦截
- 总结：触发代理对象的劫持时保证正确的 this 上下文指向。
  - Proxy 中接受的 Receiver 形参表示代理对象本身或者继承与代理对象的对象。
  - Reflect 中的 Receiver 形参表示目标对象本身。

### 2. 编译优化
<!-- - Vue2的模板是使用正则表达式解析的，性能损耗较大。
- Vue3的模板是使用AST（抽象语法树）来描述模板的，然后通过编译器将AST转换成render函数，render函数再通过with语法和虚拟DOM实现渲染。
  - 模板中的所有信息都被抽象成了AST，这样在编译过程中，只需要对AST进行处理，即可得到最终的render函数。 -->
- Vue.js 2.x 通过标记静态节点，优化 diff 的过程
- Vue.js 3.x 
  *   vue.js 3.x中标记并提升所有的静态节点，diff的时候只需要对比动态节点内容；
  *   Fragments（升级vetur插件): template中不需要唯一根节点，可以直接放文本或者同级标签
  *   静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。
  *   patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。
  *   缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数

### 3. 源码体积的优化
- 相比Vue2，Vue3整体体积变小了
- Tree-shaking
  *   Tree-shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES6 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是由 ES6 模块打包工具 Rollup 普及开的。

## 生命周期
Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 
1、beforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。 
2、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 `$el` 属性。 
3、beforeMount（挂载前） ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 
4、mounted（挂载后） ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。 
5、beforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 
6、updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 
7、beforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，`this` 仍能获取到实例。
8、destroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。 
