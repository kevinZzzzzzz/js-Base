let a = { n: 1 }
let b = a
a.x = a = { n: 2 }
/* 
  分析：
  左边a.x
  右边 a = {n: 2} 在堆内存中开辟一个地址存放{n: 2}，并将a执行这个地址， 此时b由于没有更换地址指向所以不变
  而左边的a.x是已经开辟好了的指向的是原来b的地址，相当把右边a = {n: 2}的地址赋值给左边的a.x，即b.x
*/
console.log(a.x) // undefined 因为此刻a已经被指向一块新的地址，并且没有x的属性
console.log(b.x) // {n: 2}
